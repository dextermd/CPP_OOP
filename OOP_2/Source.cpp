#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <stdlib.h>
#include <conio.h>
#include <iomanip>
#include <Windows.h>
#include <string.h>
#include <algorithm>



using namespace std;


int main()
{

    /*
    Режимы доступа:

    r — чтение, если файла нет, то данная функция
    генерирует ошибку (возвращает 0)  - для fopen

    r — чтение, если файла нет, то данная функция
    генерирует ошибку (возвращает ее код)
    и нуль в случае успеха  - для fopen_s

    w — запись, если файла нет, то файл создаётся,
        если файл есть, исходное содержимое удаляется.

    a — добавление в конец, а если файла нет, то он создаётся.

    r+ — чтение и запись (файл должен существовать).
    w+ — чтение и запись (принцип работы как у w).
    a+ — добавление и чтение (принцип работы как у a).

    wb - запись в двоичный файл
    rb - чтение из двоичного файла

    rb+ (r+b) — чтение и запись (файл должен существовать).
    wb+ (a+b) — чтение и запись (принцип работы как у w).
    ab+ (a+b) — добавление и чтение (принцип работы как у a).

*/


/*
    Язык С позволяет определять имена новых типов данных
    с помощью ключевого слова typedef.

    На самом деле здесь не создается новый тип данных,
    а определяется новое имя существующему типу.


    Он позволяет облегчить создание машинно-независимых программ.
    Единственное, что потребуется при переходе на другую платформу
    - это изменить оператор typedef.

    Стандартный вид оператора typedef следующий:

        typedef тип имя;

    где тип — это любой существующий тип данных,
    а   имя - это новое имя для данного типа.

    Новое имя определяется в дополнение к существующему имени типа,
    а не замещает его.

*/

#if 0
    // ------------------------------------------------------------------------------------------------- //
    // Текстовые и двоичные файлы ---------------------------------------------------------------------- //
    // Последовательный и произвольный доступ ---------------------------------------------------------- //
    // ------------------------------------------------------------------------------------------------- //
    // ------------------------------------------------------------------------------------------------- //
    // Запись в файл а текстовом формате, Си ----------------- fopen ----------------------------------- //
    // необходим: #define _CRT_SECURE_NO_WARNINGS ------------------------------------------------------ //
    // Общая форма  ------------------------------------------------------------------------------------ //
    // ------------------------------------------------------------------------------------------------- //

    // 1. Последовательный

    /*
    Файловый указатель — специальная переменная, которая
    автоматически присваивается открытому файлу и
    хранит текущую позицию в файле.
    */

    // Общая форма Cи

    FILE* file;

    char path[60] = "d:\\file_test\\test.txt";
    file = fopen("1.txt", "w"); // текущая папка проекта
    //file = fopen(path, "w");
    if (file)
    {
        // TODO
        fprintf(file, "Hello, summer!");
        fputs("\nПривет, лето", file); // (fputs) Запись ТОЛЬКО СТРОКИ в файл.)
        printf("\nФайл записан \n");
        fclose(file);
    }
    else {
        printf("\nОшибка записи в файл");
    }

    // Чтение файла ------------------------------------------------------------------------------

    char str[256];
    char s;

    FILE* fread;
    fread = fopen("1.txt", "r");
    if (fread)
    {
        // TODO
        //fgets(str, sizeof(str), fread); // (fgets) Чтение ТОЛЬКО 1 СТРОКИ из файла.
        //printf("\nСтрока из файлов: %s", str);


        printf("\nИнформация из файла: \n");

        //// Построчное чтение - вариант 1
        //while (!feof(fread))
        //{
        //    fgets(str, sizeof(str), fread); // (fgets) Чтение ТОЛЬКО 1 СТРОКИ из файла. (while  цикл для чтение всех строк)
        //    printf("%s", str);
        //}

        // Посимвольное чтение - вариант 2
        while (!feof(fread)) // !feof(fread) - Пока не конец файла
        {
            s = fgetc(fread); // Чтение символа с возвратом кодировки ASCHI
            if (feof(fread)) break;
            printf("%c", s);
        }

        fclose(fread);
    }
    else {
        printf("\nОшибка чтении файла");
    }

#endif


#if 1

    // ------------------------------------------------------------------------------------------------- //
    // Запись в файл в текстовом формате, Си-------------- fopen_s ------------------------------------- //
    // ------------------------------------------------------------------------------------------------- //

    FILE* fw;
    errno_t err;
    char buf[200];
    char buf_error[200];
    int a = 2023;

    err = fopen_s(&fw, "2.txt", "w"); // w - write записывать
    if (err == 0)
    {
        // TODO
        printf("\nПозиция в файле: %d", ftell(fw));
        printf("\nВведите имя: ");
        gets_s(buf, sizeof(buf));
        fprintf(fw, "\nHello, %s!!!\nГод: %d", buf, a);
        printf("\nПозиция в файле: %d", ftell(fw));
        fclose(fw);
    }else {
        printf("\nОшибка записи в файл: %d", err);
        strerror_s(buf_error, sizeof(buf_error), err);
        printf("\nERROR: %s", buf_error);
    }

    // Чтение текстового файла, Си ---------------------- fopen_s ------------------------------------- //

    FILE* fr;
    errno_t err2;
    err2 = fopen_s(&fr, "2.txt", "r");
    if (!err2)
    {
        printf("\nСодержимое файлы: \n");
        while (!feof(fr))
        {
            fgets(buf, sizeof(buf), fr);
            printf("%s", buf);
        }
        fclose(fr);
    }


#endif



#if 0

    // ------------------------------------------------------------------------------------------------- //
    // Битовые поля ------------------------------------------------------------------------------------ //
    // ------------------------------------------------------------------------------------------------- //

    struct test {
        unsigned a : 1;
        unsigned b : 4;
        unsigned c : 2;
        unsigned : 1; // не занят
    };

    cout << "\nОбьем памяти в байтах : " << sizeof(test) << endl;

    test t;
    t.a = 1;

    cout << "\nt.a = " << t.a << endl;

    t.a = 10; // 1010
    cout << "\nt.a = " << t.a << endl;

    t.b = 12;
    cout << "\nt.b = " << t.b << endl;

    t.b = 25;
    cout << "\nt.b = " << t.b << endl;

    cout << "\nВведи целое число: ";
    int x;
    cin >> x;
    t.b = x;
    cout << "\nt.b = " << t.b << endl;

#endif


#if 0

    // ------------------------------------------------------------------------------------------------- //
    // Битовые поля ------------------------------------------------------------------------------------ //
    // Запись даты и времении в структуру с битовыми полями -------------------------------------------- //
    // Обязательно провкрка правильности ввода --------------------------------------------------------- //
    // ------------------------------------------------------------------------------------------------- //

    struct date_time {
        unsigned day    : 5;
        unsigned month  : 4;
        unsigned year    : 11;
        unsigned hour   : 5;
        unsigned minut  : 6;

    };

    int d;
    date_time dt;
    cout << sizeof(date_time) << endl; // 4
    
    cout << "\nДень: ";
    cin >> d;
    dt.day = d;

    cout << "\nМесяц: ";
    cin >> d;
    dt.month = d;

    cout << "\nГод: ";
    cin >> d;
    dt.year = d;

    cout << "\nЧасы: ";
    cin >> d;
    dt.hour = d;

    cout << "\nМинуты: ";
    cin >> d;
    dt.minut = d;

    cout << "\nДата:  " << dt.day << "." << dt.month << "." << dt.year;
    cout << "\nВремя: " << dt.hour << ":" << dt.minut;

#endif


#if 0

    // ------------------------------------------------------------------------------------------------- //
    // Обьединение - union ----------------------------------------------------------------------------- //
    // ------------------------------------------------------------------------------------------------- //
    /*
    Объединения — это тип класса, в котором все данные 
    разделяют одну и туже область памяти.

    Объединения применяются для:
        -    минимизации используемого объема памяти,
             если в каждый момент времени только один объект из многих является активным;

        -    интерпретации основного представления объекта одного типа,
            как если бы этому объекту был присвоен другой тип.
    */

    union test {
        char ch;
        int x;
        double d;
    };

    cout << "\nОбьем памяти : " << sizeof(test);

    test t;
    t.ch = '+';
    cout << "\nt.ch = " << t.ch; // +
    cout << "\nt.x = " << t.x;   // Мусор
    cout << "\nt.d = " << t.d;   // Мусор

    cout << endl << endl;

    t.x = 43;
    cout << "\nt.ch = " << t.ch; // +
    cout << "\nt.x = " << t.x;   // 43
    cout << "\nt.d = " << t.d;   // Мусор

    cout << endl << endl;

    t.d = 25.45;
    cout << "\nt.ch = " << t.ch; // Мусор
    cout << "\nt.x = " << t.x;   // Мусор
    cout << "\nt.d = " << t.d;   // 25.45

    cout << endl << endl;

    //-----------------------------------------------------------------

    /*
    Анонимное объединение просто уведомляет компилятор о том, 
    что его переменные-члены должны иметь одну и туже область памяти. 
    Но к самим переменным можно обращаться напрямую, 
    не прибегая к обычному синтаксису операторов "." и "->". 
    Анонимные объединения должны содержать только данные, 
    никакие функции-члены не допускаются.
    */

    // enum names { BMW, LADA}; // Анонимное пересичление

    // Анонимное обьединение
    union {
        int k;
        char str[20];
        double d;
    };

    k = 25;

    cout << "\nk = " << k;
    cout << "\nstr = " << str;
    cout << "\nd = " << d;

#endif


#if 0

    // Битовые поля в объединениях используются для доступа 
    // к нужным битам того или иного объекта, 
    // входящего в объединение.

    struct byte {
        unsigned a0 : 1;
        unsigned a1 : 1;
        unsigned a2 : 1;
        unsigned a3 : 1;
        unsigned a4 : 1;
        unsigned a5 : 1;
        unsigned a6 : 1;
        unsigned a7 : 1;
    };

    union byte_union {
        int value;
        byte bitf; // Экземпляр структуры byte
    };

    byte_union bu;
    bu.value = 25;

    cout << bu.bitf.a7 << bu.bitf.a6 << bu.bitf.a5 << bu.bitf.a4
         << bu.bitf.a3 << bu.bitf.a2 << bu.bitf.a1 << bu.bitf.a0 << endl;

    byte_union bu2;
    struct byte b {0,0,0,1,1,0,0,1};
    bu2.bitf = b;

    cout << bu2.value << endl;

    byte_union bu3;
    struct byte b3 { 1, 0, 0, 1, 1, 0, 0, 0 };
    bu3.bitf = b3;

    cout << bu3.value << endl;

#endif

    _getch();
}
