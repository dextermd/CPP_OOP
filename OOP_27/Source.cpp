#include <iostream>
#include <iomanip>
#include <Windows.h>
#include "MyString.h"
#include "Person.h"
#include "Student.h"
#include "Worker.h"
#include "Circle.h"
#include "Cylinder.h"
#include "WorkerStudent.h"
#include "Shape.h"
#include "Triangle.h"
#include "Crug.h"
#include "StackD.h"
#include "123.h"
#include "SmartPointerT.h"
#include <conio.h>
#include "Coord.h"


using namespace std;

auto f(int a) { return a; }
//auto f2(auto a) { return a; }  //Error	C3533	a parameter cannot have a type that contains 'auto'	



// Указатель на объект является константным, следовательно, через него 
// изменить значение объекта нельзя
void test(const int* v) {
	int* temp;
	//temp = v;  // ошибка 
	//temp = (int *)v;    // синтаксис Си

	//снимаем модификатор const и теперь можем изменять объект
	temp = const_cast<int*>(v);// синтаксис С++

	*temp = (*v) * (*v);  //изменение объекта

	cout << "\n&temp = " << temp << endl;
	cout << "\ntemp = " << *temp << endl;
}
//--------------------------------------------------------------------------
void func(const char* str)
{
	int k = 0;
	char* t1, * t2;

	t1 = strtok_s(const_cast<char*>(str), " ", &t2);
	while (t1)
	{
		cout << t1 << endl;
		t1 = strtok_s(nullptr, " ", &t2);
	}
}

//--------------------------------------------------------------------------
template <typename T>
void func1(T*& value) { (*value)++; }

template <typename T>
void func2(const T* value) { cout << (*value) << endl; }

//--------------------------------------------------------------------------


int main()
{
	/*system("chcp 1251>nul");
	system("color 1F");*/
	setlocale(LC_ALL, "Russian");

	//-----------------------------------------------------------------------
	/* Преобразование типов в стиле С++  STL
			static_cast
			const_cast
			dynamic_cast
			reinterpret_cast
	*/


	//-----------------------------------------------------------------------
	// Приведение типа в С++
	//-----------------------static_cast   -----------------------------------
	/*
	Синтаксис:	TYPE static_cast<TYPE> (object);

	<TYPE> - тип данных, к которому необходимо преобразовать значение - (object)

	static_cast (шаблонный конейнер) преобразует выражения одного
	статического типа в объекты
	и значения другого статического типа.

	Поддерживается преобразование численных типов,
	указателей и ссылок по иерархии наследования как вверх, так и вниз.
	Проверка производится на уровне компиляции,
	так что в случае ошибки сообщение будет получено
	в момент сборки приложения или библиотеки.

	Проверка типов выполняется на момент компиляции,
	не проверяется  в момент выполнения программы.

	Выполняет неполиморфное приведение типов.

	*/
#if 0
	double res = (double)10 / 3;    // синтаксис Си
	//TYPE static_cast<TYPE> (object);

	double res2 = static_cast<double>(10) / 3;
	cout << res2 << endl;

	int k = static_cast<int>('a');
	cout << k << endl;


	char str[] = "A12365";
	int t = (int)str;					 //компилируется
	cout << t << hex << "  " << t << dec << "  " << endl;
	cout << (char*)t;

	//int a = static_cast<int>(str);	 //ошибка компиляции

#endif

	/*
	 Рекомендуется пользоваться операцией static_cast,
	 нежели Cи-стилем приведения, потому что static_cast
	 ограничивает недопустимое приведение типов и,
	 следовательно — безопаснее.
	*/



	//-----------------------------------------------------------------------
#if 0
	cout << "\nПриведение ВВЕРХ--------static_cast------------------\n\n";
	Circle a(5, 6, 1);

	// объект производного класса к объекту базового(приведение вверх) С
	Coord b = a;
	cout << b << endl;

	// объект производного класса к объекту базового(приведение вверх) С++
	Coord  c = static_cast<Coord>(a);
	c.show();
	cout << endl;

	// ссылка на объект производного класса к указателю на базовый класс
	Coord* ptr = &a;  // Си, без приведения типа
	Coord* p = static_cast<Coord*>(&a);
	p->show(); // circle

#endif

	//-----------------------------------------------------------------------
	// ***объект базового класса приводится к объекту производного класса 
	//(приведение вниз)

#if 0
	cout << "\nПриведение ВНИЗ--------static_cast------------------\n\n";
	// круг -> цилиндр

	Circle* cr = new Circle(1, 5, 15);

	//1
	Cylinder* cl = (Cylinder*)cr; //CИ  Нет ошибки , выведется  1, 5, 15

	//2
	//Cylinder* cl = static_cast<Cylinder*>(cr);// С++   Нет ошибки , выведется  1, 5, 15

	//3
	//Cylinder* cl = dynamic_cast<Cylinder*>(cr);//Ошибка приведения типа

	if (cl)
	{
		cl->show();
	}
	else cout << "\nОшибка приведения типа";

	delete cr;


#endif // 0

	//-----------------------------------------------------------------------
	// Приведение типа в С++
	//-----------------------const_cast   -----------------------------------
	/*
	Синтаксис:	TYPE const_cast<TYPE> (object);

	Пожалуй самое простое приведение типов.
	Снимает cv qualifiers — const и volatile,
	то есть константность и отказ от оптимизации
	компилятором переменной.

	Это преобразование проверяется на уровне компиляции
	и в случае ошибки приведения типов будет выдано сообщение.

	*/

	/*
	Ключевое слово volatile информирует компилятор,
	что значение переменной может меняться извне.

	Это может произойти под управлением
	операционной системы, аппаратных средств или
	другого потока.
	*/

	//https://ci-plus-plus-snachala.ru/?p=4964

	/*
	- Явное приведение типа const_cast используют для того,
	чтобы отбросить квалификатор const у изначально не константных данных или добавить квалификатор const.

	- const_cast не влияет на оригинальную переменную: не убирает её const и не добавляет ей const

	ВНИМАНИЕ!
	Отбрасывание квалификатора const у переменных,
	которые изначально живут с приписанным им квалификатором const,
	может привести к неопределённому поведению программы.

	Т. е. любые попытки изменить переменную, с момента рождения которой было приписано не изменяться,
	ведёт к непрогнозируемому поведению, т. е. UB(undefined behavior).
	*/


	//Пример 1:  снятие константности-----------------------------------------

#if 0

	int x = 10;
	const int N = 100;
	const int* ptr = &N;

	/*const*/ /*int *k = &N; */// ошибка

	int* p = const_cast<int*>(&N);	// Снятие const с переменной, на которую указывает p
	(*p) = 200;						// Изменение переменной, которая обозначена const

	cout << (void*)&N << '\t' << N << '\n';	    // На экране - один адрес,
	cout << (void*)p << '\t' << *p << '\n';     // но разные значения
	// ...изменение переменной, которая инициализирована как const – 
	// это неопределённое поведение работы программы в дальнейшем(undefined behaviour)


#endif // 0




	//Пример 2:   снятие константности----------------------------------------
#if 0

	int a = 10;
	const int* p = &a;     // *p имеет тип const int / p - указатель на константу
	// p указывает на int, который константным не является
	//(*p)++; // не разрешено, ошибка
	//a++;

	//int* p2 = p;   // ошибка компиляции 

	int* p2 = const_cast<int*> (p);
	(*p2)++;  // разррешено, константность снята
	cout << *p << "   " << p << endl;
	cout << *p2 << "   " << p2 << endl << endl;

#endif // 0


	//Пример 3:  снятие константности-----------------------------------------
#if 0


	char s[] = "hello world привет мир";
	func(s);
	//func("hello world привет мир");// ошибка 

#endif // 0

	//Пример 4:  снятие константности-----------------------------------------
#if 0

	int x = 10;
	cout << "Before - " << x << "\n\n";
	test(&x);

	cout << "After - " << x << "   &x = " << &x << "\n\n";

#endif // 0



	//Пример 5:  добавление константности--------------------------------------
#if 0

	int* v = new int(25);

	func1(v);
	cout << *v << endl;

	func2(v);

	func2(const_cast<const int*>(v));
	cout << *v << endl;

	//func1(const_cast<const int*>(v)); // приведение с добавлением const
	// ошибка, т.к. func1 принимает не const

	delete v;

#endif // 0





	//-----------------------typeid------------------------------------------
	/*
	В языке C++ typeid возвращает ссылку на объект type_info,
	описывающий тип объекта.

	Общая форма записи оператора typeid:  typeid(объект)

	Оператор typeid поддерживает в языке C++ возможность
	идентификации динамической информации о типе RTTI
	(run-time type identification — RTTI).

	*/

#if 0

	int a = 7;
	cout << typeid(a).name() << endl;

	Coord* c = new Coord(5, 25);
	cout << typeid(c).name() << endl;
	//идентификация типа во время выполнения программы

	auto b = 'A';
	cout << typeid(b).name() << endl;

	auto* p = new double(3.6);
	cout << typeid(p).name() << endl;  //идентификация типа во время выполнения программы

	if (typeid(c).name() == typeid(Coord*).name())
		cout << "\nCOORD\n";
	else cout << "\nno";

	delete c;
	delete p;


	auto x = f('+');
	cout << typeid(x).name() << endl;

	x = f(2.65);
	cout << typeid(x).name() << endl;

#endif // 0


	// Приведение типа в С++
	//-----------------------dynamic_cast   -----------------------------------
	/*
	 dynamic_cast выполняет проверку на тип во время выполнения программы,
				  поэтому работает только со ссылками или указателями

	Синтаксис:		TYPE& dynamic_cast<TYPE&> (object);
				TYPE* dynamic_cast<TYPE*> (object);

	Используется для динамического приведения типов во время выполнения.
	В случае неправильного приведения типов для ссылок
	вызывается исключительная ситуация std::bad_cast,
	а для указателей будет возвращен 0.
	Использует систему RTTI (Runtime Type Information).
	Безопасное приведение типов по иерархии наследования,
	в том числе для виртуального наследования.
	*/


	// Восходящее приведение типа------------------------------------------------------
	// Указатель перемещается вверх по иерархии классов
#if 0

	cout << "\n----------приведение ВВЕРХ------dynamic_cast------------------1\n\n";
	// приведение круга к координате
	{
		Coord* k;
		Circle crug(5, 5, 5.0);

		k = dynamic_cast<Coord*>(&crug);// приведение circle к coord *
		if (k)
		{
			k->show();
		}
		else
			cout << "\nОшибка приведения типа\n";
	}

	cout << "\n----------приведение ВВЕРХ------typeid----------------------2\n\n";
	{
		// приведение круга к координате
		Coord* k;
		Circle crug(5, 5, 5.0);

		k = &crug;
		if (typeid(crug) == typeid(*k))
		{
			cout << typeid(crug).name() << "  " << typeid(*k).name() << endl;//class circle
			k->show();
		}
		else
			cout << "\nОшибка приведения типа\n";
	}

#endif // 0

#if 0
	cout << "\n----------приведение ВНИЗ------dynamic_cast------------------3\n\n";
	// приведение координаты к кругу
	{
		Coord k(25, 25);
		Circle* crug;

		crug = dynamic_cast<Circle*>(&k);// приведение coord  к circle*
		if (crug)
		{
			crug->show();
		}
		else
			cout << "\nОшибка приведения типа\n";//!!!
	}

	cout << "\n****----------приведение ВНИЗ------typeid----------------------4\n\n";
	{
		// приведение координаты к кругу
		Coord k(25, 25);
		Circle* crug;

		//crug = &k;// ошибка компиляции
		crug = dynamic_cast<Circle*>(&k);

		if (typeid(Circle) == typeid(&k))
		{
			cout << typeid(*crug).name() << "  " << typeid(k).name() << endl;//class circle
			crug->show();
		}
		else
			cout << "\nОшибка приведения типа\n";//!!!
	}
#endif // 0


#if 0
	// Пример: приведение Цилиндра к координате
	// Вариант 1 (без shared_ptr)

	Cylinder* pcyl = new Cylinder(0, 0, 2.5, 8);

	if (pcyl) {
		Circle* pc = dynamic_cast<Circle*>(pcyl);

		if (pc)
		{
			cout << endl << typeid(pc).name() << endl;
			pc->show();
			delete pc; //*** не надо, если использовать shared_ptr
		}
		else cout << "\nError";
		//delete pcyl;   // вылет, т.к. pc  и pcyl ссылаются на один адрес
	}


#endif // 0

#if 0
	// Пример: приведение Цилиндра к координате
	// Вариант 2 ( + shared_ptr)

	Cylinder* pcyl = new Cylinder(0, 0, 2.5, 8);

	shared_ptr<Cylinder> ptr(pcyl); //***

	// или
	//shared_ptr<Cylinder> ptr(new Cylinder(0, 0, 2.5, 8));

	// или
	//auto ptr = make_shared<Cylinder>(0, 0, 2.5, 8);//auto ptr = make_shared<cylinder>();

	if (pcyl) {
		Circle* pc = dynamic_cast<Circle*>(pcyl);

		if (pc)
		{
			cout << typeid(pc).name() << endl;
			pc->show();
			//delete pc; //*** уже не надо, т.к. работает shared_ptr
		}
		else cout << "\nError";

	}

#endif // 0



	// Нисходящее приведение типа------------------------------------------------------
	// Нельзя проводить преобразование классов по иерархии вниз, 
	// если базовый класс не содержит virtual, т.е. работает только
	// для полиморфных классов

#if 0

	Circle* cr = new Cylinder(1, 5, 15, 20);   /*new circle(1, 5, 15);*/

	shared_ptr<Circle> ptr(cr);//**** ADD

	Cylinder* cl = dynamic_cast<Cylinder*>(cr);
	if (cl)
	{
		cout << typeid(cl).name() << endl;
		cl->show();
	}
	else cout << "\nОшибка приведения типа";

	//delete cr; //**** не надо в случае shared_ptr<circle> ptr(cr);

#endif // 0


	/*
	Правило: Указатель базового класса можно привести к указателю производного
	только в случае, если указатель ссылается на объект производного класса
	(что на этапе компиляции может быть неизвестно).

	Проверить это в рантайме получится только для полиморфных классов.
	*/

	/*
	Итог:
	- Повышающее преобразование всегда безопасно,
	  и даже может происходить неявно.

	- Понижающее преобразование потенциально опасно, и чтобы его произвести,
	  необходимо выполнять его явным образом.
	*/


	//-----------------------------------------------------------------------------------
	//	Пример: Низходящее приведение типа и обработка исключения

#if 0

	Circle* cr = new Cylinder(1, 5, 15, 6);  //new Circle(1, 5, 15);

	if (cr) {

		//shared_ptr<Circle> ptr(cr);//*** shared_ptr

		Cylinder* cl = nullptr;

		try {
			cl = dynamic_cast<Cylinder*>(cr);

			if (!cl)
				throw exception("\nНеверное приведение типа");

			cout << typeid(cl).name() << endl;

			cl->init(); // выбрасывается исключение const char* ex в случае ввода отриц. высоты
			cl->show();

			delete cr; //***не надо в случае использования shared_ptr<circle> ptr(cr);
		}
		catch (exception& ex)
		{
			cout << ex.what();
			// *** Не надо в случае shared_ptr<circle> ptr(cr);
			delete cl; // срабатывает в случае init и вводе отрицательной высоты 
		}


	}
#endif // 0


	//-----------------------reinterpret_cast --------------------------------------
	/*
	Синтаксис: 	TYPE reinterpret_cast<TYPE> (object);
	Приведение типов без проверки.
	reinterpret_cast — непосредственное указание компилятору.
	Применяется только в случае полной уверенности программиста
	в собственных действиях.

	Не снимает константность и volatile.
	Применяется для приведения указателя к указателю,
	указателя к целому и наоборот.

	*/
#if 0

	char str[] = "Hello";
	//int ptr = (int)str;
	int a = reinterpret_cast<int>(str);
	cout << a << hex << "  " << a << dec << endl;


	int* p = &a;
	double* d = reinterpret_cast<double*>(p);
	cout << *d << endl;//


	Circle cr(0, 0, 1);
	//Coord  c = reinterpret_cast<Coord>(cr);  // ошибка компиляции


	Coord  c = (Coord)cr;  // Си
	Coord c2 = static_cast<Coord>(cr);// С++
	c.show();
	c2.show();

#endif // 0





	_getch();
	return 0;
}





//----------------------------------------------------------------------------------

/*
typeid - Ключевое слово используется для определения класса
		 в качестве объекта на время выполнения.
		 Возвращает ссылку на std::type_info объект,
		 который существует до конца программы.

		 Использование typeid в неполиморфном контексте часто предпочтительнее,
		 чем в ситуациях, когда требуется только информация о классе,
		 потому что это всегда процедура с постоянным временем.
		 (Wikipedia)

http://www.cplusplus.com/reference/typeinfo/type_info/
*/

//----------------------------------------------------------------------------------
/*
Использование спецификатора const с указателями:

1.	int *ptr – это указатель.
	Можно изменить значение, на которое он указывает: 		(*ptr )++;
	Можно изменить значение (адрес), которое в нем содержится: 	 ptr++;

2.	const int *ptr – это указатель на константу.
	Нельзя изменить значение, на которое он указывает: 		(*ptr )++; // ошибка
	Можно изменить значение (адрес), которое в нем содержится: 	 ptr++;

3.	int * const ptr -  это константный указатель.
	Можно изменить значение, на которое он указывает: 		(*ptr )++;
	Нельзя изменить значение (адрес), которое в нем содержится: 	 ptr++;    // ошибка

4.	const int * const ptr – это константный указатель на константу.
	Ничего менять нельзя.

*/





