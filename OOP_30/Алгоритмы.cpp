

#include <iostream>
#include <conio.h>
#include <vector>
#include <algorithm>
#include <numeric>
#include <set>
#include "Coord.h"
#include "person.h"

using namespace std;

//------------------------------------------------------------------------
template<class T>
void show(vector<T> v)
{
	for (auto p = v.begin(); p != v.end(); ++p)
	{
		cout << *p << "   ";
	}
	cout << endl;
}
//------------------------------------------------------------------------
bool is_even(int a)
{
	return a % 2 == 0;
}
//------------------------------------------------------------------------
struct Even {
	bool operator()(int a)const
	{
		return a % 2 == 0;
	}
};
//------------------------------------------------------------------------
bool is_value(int a)
{
	return a == 25;
}
//------------------------------------------------------------------------
struct IsValue {

	int value;
	IsValue(int v) : value(v) {}

	bool operator()(int v)
	{
		return this->value == v;
	}
};
//------------------------------------------------------------------------
struct CompRange
{
	int a;
	int b;

	CompRange(const int& a, const int& b) : a(a), b(b) {}

	bool operator()(const int& value)const
	{
		return value >= a && value <= b;
	}
};

//------------------------------------------------------------------------
// Предикат
struct CompPerson {
	string str;

	CompPerson(string x) : str(x) {}

	bool operator()(const Person& p)
	{
		return p.get_surname() == str;
	}
};
//------------------------------------------------------------------------
// Унарный предикат
struct Odd
{
	bool operator()(const int a) const
	{
		return a % 2 != 0;
	}
};

//------------------------------------------------------------------------
bool mypredicate(int a, int b)
{
	return (a / 10 == b);
}

//------------------------------------------------------------------------
void print(const int& v)
{
	cout << "\"" << v << "\"   ";
}

//------------------------------------------------------------------------
void doublevalue(int& v) {//for_each
	v *= 2;
}

//------------------------------------------------------------------------
long double_value(int& v) {//transform
	return v * 2;
}

//------------------------------------------------------------------------
bool comp_pair(pair<string, int>a, pair<string, int>b)
{
	return a.second > b.second;
}

//------------------------------------------------------------------------
bool mycompare(int a, int b) { return a > b; } // для sort   и partial_sort

//------------------------------------------------------------------------

int main()
{
	system("chcp 1251>nul");
	system("color 1F");

	/*
	Алгоритмы:
		http://ru.cppreference.com/w/cpp/algorithm

		http://www.cplusplus.com/reference/algorithm/

	Классификация алгоритмов:
		- немодифицирующие алгоритмы
		- модифицирующие алгоритмы
		- алгоритмы удаления
		- перестановочные алгоритмы
		- алгоритмы сортировки
		- алгоритмы упорядоченных интервалов
		- численные алгоритмы

	*/


	// Немодифицирующие алгоритмы-------------------------------------------------


	/*
	count-------------------------------------------------------------------------
	Возвращает, сколько раз элемент со значением x входит в последовательность,
	заданную итераторами.
	*/
#if 0

	vector<int> v{ 25, 9, 489, -3, 10, 2, 25, 6, 25, 24, 25 };

	for (auto x : v)
	{
		cout << x << "  ";
	}
	cout << "\nКоличество повторений: " << count(v.begin() + 2, v.end() - 2, 25);


#endif // 0




	/*
	count_if----------------------------------------------------------------------
	Возвращает, сколько раз предикатная функция(булевая) возвращает значение true.
	*/

	// Задача:-------------------------------------------------------------------
	// Посчитать количество четных элементов вектора

#if 0

	vector<int> v{ 250, 9, 489, -3, 10, 2, 25, 6, 25, 24, 25 };

	//is_even - Унарная предикатная функция
	cout << "\nКоличество четных значений: " << count_if(v.begin(), v.end(), is_even);

	//Even - Унарный предикат
	cout << "\nКоличество четных значений: " << count_if(v.begin(), v.end(), Even()) << endl;

	// Как это работает:

	//Even object;
	//int k = 0;
	//cout << object(4) << endl;// operator()
	//for (auto x : v)
	//{
	//	if (object(x)) {
	//		k++;
	//	}
	//}
	//cout << "\nКоличество четных значений: " << k << endl;

#endif // 0




	// Задача:-------------------------------------------------------------------
	// Посчитать количество повторений определенного значения в векторе
#if 0

	vector<int> v{ 250, 9, 489, -3, 10, 2, 25, 9, 25, 24, 25 };
	int key = 25;

	/*cout << "\nКоличество повторения значения " << key << ":  "
		<< count_if(v.begin(), v.end(), is_value);*/


	cout << "\nКоличество повторения значения " << key << ":  "
		<< count_if(v.begin(), v.end(), IsValue(key));//IsValue - Предикат

#endif // 0






	// Самостоятельно:-------------------------------------------------------------
	// Посчитать количество элементов вектора, попадающих в определенный диапазон 
	// (например, от 8 до 25)



#if 1

	vector<int> v{ 250, 9, 489, -3, 10, 2, 25, 6, 25, 24, 25 };

	int a = 100, b = 500;

	cout << "\nКоличество элементов вектора в диапазоне от " << a << " до " << b << ": "
		<< count_if(v.begin(), v.end(), CompRange(a, b)) << endl;

	cout << "\nКоличество элементов вектора в диапазоне от " << a << " до " << b << ": "
		<< count_if(v.begin(), v.end(), [a, b](int x) {return x >= a && x <= b; }) << endl;

#endif // 0


	//==============================================================================
	// Для самостоятельного ознакомления и возможного решения заданий по StudentSTL
	//==============================================================================


	// Задача(самостоятельно): ------------------------------------------------------***
	// Посчитать для списка студентов (StudentSTL):
	// - Количество студентов определенного возраста
	// - Количество студентов определенного возраста(от-до) 
	// - Количество студентов, у которых средний балл больше определенного заначения











	/*
	all_of------------------------------------------------------------------------
	Проверяет, что предикат возвращает значение true для всех элементов в диапазоне
	[first, last).
	*/
#if 0
	vector<int> v{ 250, 9, 489, -3, 10, 2, 25, 6, 25, 24, 25 };

	//if (all_of(v.begin(), v.end(), is_even))
	if (all_of(v.begin(), v.end(), Even()))
	{
		cout << "\nВсе значения четные";
	}
	else {
		cout << "\nНе все  значения четные";
	}
#endif





	//max_element------------------------------------------------------------------
#if 0
	vector<int> v{ 250, 9, 489, -3, 10, 2, 25, 6, 25, 24, 25 };

	auto it = max_element(v.begin(), v.end());
	cout << "\nМаксимальное значение: " << *it << endl;
	cout << "\nИндекс максимального значения: " << it - v.begin() << endl;
	cout << "\nИндекс максимального значения: " << distance(v.begin(), it) << endl;

#endif // 0


	// Задача(самостоятельно): ----------------------------------------------***
	// - Определить и вывести на экран  студента с максимальным средним баллом
	// - Вывести на экран список всех студентов с максимальным средним баллом в группе








	// find---------------------------------------------------------------
	// Задача: Найти первое вхождения определенного занчения в массив
	// и вывести его  индекс.

#if 0
	vector<int> v{ 250, 9, 489, -3, 10, 2, 25, 6, 25, 24, 25 };
	show(v);

	int value = 25;
	auto it = find(v.begin(), v.end(), value);

	if (it != v.end())
	{
		cout << "\nЗначение " << value << " найдено по индексу : " << distance(v.begin(), it);
	}
	else {
		cout << "\nЗначение не найдено ";
	}
#endif // 0





	// Задача(самостоятельно): -------------------------------------------
	// Найти все вхождения числа в вектор и вывести на экран индексы
	// алгоритм find


#if 0

	vector<int> v{ 250, 9, 489, -3, 10, 2, 25, 6, 25, 24, 25 };
	show(v);

	int value = 25;
	auto it = find(v.begin(), v.end(), value);// первое вхождение

	if (it != v.end())
	{
		cout << "\nИндексы вхождения значения " << value << " в вектор: ";
		while (it != v.end())
		{
			cout << distance(v.begin(), it) << "  ";
			it = find(it + 1, v.end(), value);// следующие вхождения
		}
	}
	else {
		cout << "\nЗначение не найдено ";
	}

#endif // 0





	// find_if---------------------------------------------------------------
	// find_if ищет элемент, для которого предикат  возвращает значение true

	// Задача: найти первое вхождение нечетного значения в вектор
#if 0

	vector <int> v{ 26, 8, 24, -3, 50, -1, 8, 25, 8 };
	show(v);

	auto it = find_if(v.begin(), v.end(), Odd());
	if (it == v.end())
		cout << "\nЭлементов по условию в векторе нет" << endl << endl;
	else cout << "\nПервый элемент по условию: " << *it << endl << endl;

#endif // 0





	// Задача(самостоятельно): ----------------------------------------------***
	// Найти и вывести на экран всех студентов определенного Вуза




	//------------------------------------------------------------------
	// **** Код для самостоятельного рассмотрения на прошлом уроке № 29
	// **** Можно посмотреть самостоятельно, рассмотрим на следующем уроке.
#if 0

	Person _person("Borisov", "Ivan", 30, 180, 75);

	set<Person> set_person;
	set_person.insert(_person);

	set_person.insert(Person("Artemova", "Kate", 15, 160, 50));//!!!
	set_person.emplace("Dimov", "Tim", 20, 170, 65);

	//set_person.insert("Tim", "Dimov", 20, 170, 65); // error

	for (auto v : set_person)
	{
		v.show();
	}


	string fam = "Artemova";
	// Поиск по алгоритму find_if с использованием предиката - 1
	auto result = find_if(set_person.begin(), set_person.end(), CompPerson(fam));//предикат



	// Поиск по алгоритму find_if с использованием лямбда-выражения  - 2

	/*auto result = find_if(set_person.begin(), set_person.end(),
				  [&fam] (const Person& obj) {return obj.get_surname() == fam; });*/


	if (result != set_person.end())
	{
		cout << "\n\nЭлемент найден:--------------------\n";
		result->show();
	}
	else cout << "\n\nЭлемент не найден";


#endif // 0



	//search---------------------------------------------------------------------
	// поиск вхождения последовательности

	// Задача: Определить вхождение значений одного вектора в другой и 
	// вывести индекс начала вхождения.
#if 0

	vector<int> v1, v2{ 40,50,60,70 };

	for (int i = 1; i < 10; i++)
	{
		v1.push_back(i * 10);
	}
	show(v1);
	show(v2);

	auto it = search(v1.begin(), v1.end(), v2.begin(), v2.end());
	if (it != v1.end())
	{
		cout << "\nВхождение найдено, индекс начала вхождения: " << distance(v1.begin(), it);
	}
	else
	{
		cout << "\nНет вхождения последовательности";
	}

#endif


	// Задача: Определить вхождение значений одного вектора в другой по условию(значения кратны) 
	// вывести индекс начала вхождения.
#if 0
	vector<int> v1, v3{ 5,6 ,7 };

	for (int i = 1; i < 10; i++)
	{
		v1.push_back(i * 10);
	}
	show(v1);
	show(v3);

	// Поиск по предикатной функции
	auto it = search(v1.begin(), v1.end(), v3.begin(), v3.end(), mypredicate);

	if (it != v1.end())
	{
		cout << "\nВхождение найдено, индекс первого вхождения: " << distance(v1.begin(), it);
	}
	else
	{
		cout << "\nНет вхождения последовательности";
	}

#endif // 0





	//--------------------------------------------------------------------------
	// Модифицирующие алгоритмы-------------------------------------------------
	//for_each------------------------------------------------------------------

#if 0

	vector <int> v{ 26, 8, 24, -3, 50, -1, 8, 25, 8 };

	for_each(v.begin(), v.end(), print);
	cout << endl;

	for_each(v.begin(), v.end(), doublevalue);

	for (auto x : v)
	{
		cout << x << "  ";
	}

#endif // 0



	//transform------------------------------------------------------------------
	// Применяет параметр-функцию к различным элементам 
	// Результат может быть как в исодный люъект, так и в другой
#if 0

	vector <int> v{ 26, 8, 24, -3, 50, -1, 8, 25, 8 };

	vector<int> dv(9);

	show(v);
	show(dv);

	transform(v.begin(), v.end(), dv.begin(), double_value);

	show(dv);


#endif // 0


	//сравнение  for_each и transform---------------------------------------------------
	/*
	for_each   - алгоритму передается операция, которая модифицирует его элемент,
				т.е. аргумент должен передаваться по ссылке

	transform - использует операцию, которая возвращает модифицированный аргумент.
				Результат присваивается исходному элементу.

	Алгоритм transform работает немного медленнее, но более гибок, т.к. он может использоваться
	для модификации элементов в процессе копирования в другой интервал.

	Кроме того есть перегруженная версия, которая позволяет обрабатывать и комбинировать
	элементы из двух разных интервалов.

	*/


	// transform-----------------------------------------------------------------------
	// Перевод строки string в верхний/нижний регистр----------------------------------
#if 0
	string str = "hello, world!";

	transform(str.begin(), str.end(), str.begin(), toupper);
	cout << endl << str << endl;

#endif // 0




	// Задача(самостоятельно):----------------------------------------------------------
	// Дан массив строк (string), символы в разных регистрах
	// string mas[]{ "peN", "taBle","windoW", "noteBOOK" };
	// 1. Перевести весь массив строк в нижний регистр
	// 2. Перевести первый символ каждой строки в  верхний регистр


#if 0

	string mas[]{ "peN", "taBle","windoW", "noteBOOK" };

	for (auto& s : mas)
	{
		transform(s.begin(), s.end(), s.begin(), tolower);
		transform(s.begin(), s.begin() + 1, s.begin(), toupper);
	}

	for (auto s : mas) {
		cout << s << endl;
	}
	cout << endl << endl;

#endif // 0








	// stable_sort-----------------------------------------------------------------
	/* Сортирует элементы в диапазоне [первый, последний] в порядке возрастания, как sort,
	 но stable_sort сохраняет относительный порядок элементов с эквивалентными значениями.

	Увидеть отличие между результатами работы стандартных алгоритмов сортировки библиотеки STL:
	сортировки sort() и стабильной сортировки stable_sort() можно только на больших
	массивах исходных данных.
	*/

#if 0

	vector < pair<string, int> >st{ {"Val0", 6}, { "Val1", 6 }, { "Val2", 4 },
		{ "Val3", 6 }, { "Val4", 6 }, { "Val5", 4 },
		{ "Val6", 4 }, { "Val7", 6 }, { "Val8", 4 },
		{ "Val9", 5 }, { "Val10", 6 }, { "Val11", 6 },
		{ "Val12", 5 }, { "Val13", 6 }, { "Val14", 5 },
		{ "Val15", 5 }, { "Val16", 4 }, { "Val17", 6 },
		{ "Val18", 5 }, { "Val19", 4 }, { "Val20", 6 },
		{ "Val21", 4 }, { "Val22", 4 }, { "Val23", 5 },
		{ "Val24", 4 }, { "Val25", 5 }, { "Val26", 6 },
		{ "Val27", 4 }, { "Val28", 5 }, { "Val29", 4 },
		{ "Val30", 4 }, { "Val31", 4 }, { "Val32", 5 } };


	for (auto v : st)
	{
		cout << v.first << "  " << v.second << endl;
	}

	//sort(st.begin(), st.end(), comp_pair);
	stable_sort(st.begin(), st.end(), comp_pair);

	cout << "\n После stable_sort\n";
	for (auto v : st)
	{
		cout << v.first << "  " << v.second << endl;
	}

#endif // 0

	// ranges::sort-----------------------------------------------------------------С++20
#if 0
	vector <int> v{ 26, 8, 24, -3, 50, -1, 8, 25, 8 };
	show(v);

	//sort(v);// error
	ranges::sort(v);
	show(v);

	/*
	 Основное различие заключается sort и ranges::sort :
	 sort работает с итераторами,
	 ranges::sort работает с диапазонами, что делает его более удобным и гибким
	*/


#endif // 0


	// partial_sort-----------------------------------------------------------------
	/*
	partial_sort() сортирует часть последовательности,
	укладывающуюся в диапазон [first,middle], где middle - второй параметр.
	Элементы в диапазоне [middle,last] остаются неотсортированными.

	Элементы сравниваются с помощью оператора < для первой версии,
	и по предикатной функции для второй.
	*/

#if 0

	vector<int> v{ 25, -6, 9, 10, -125, 8, 19, 45, -30 };
	cout << "\nИсходный массив:\n";
	show(v);

	cout << "\nМассив после сортировки, сравнение по умолчанию (<) :\n";
	partial_sort(v.begin(), v.begin() + 5, v.end());
	show(v);


	/*
	v.begin() + 5 - указывает на 6-ой элемент
	генерируется последовательность, в которой наименьшие пять
	(т.е. middle-first) элементов отсортированы
	*/

	cout << "\nМассив после сортировки, сравнение по предикатной функции :\n";
	partial_sort(v.begin(), v.begin() + 5, v.end(), mycompare);
	show(v);

#endif // 0



	//------------------------------------------------------------------------------------
	//Алгоритмы  partition и stable_partition
#if 0

	vector<int> v{ 25, -6, 9, 10, -125, 8, 19, 45, -30 };

	show(v);

	partition(v.begin(), v.end(), Even());

	cout << "\nВектор после partition:\n";
	show(v);

	/*stable_partition(v.begin(), v.end(), Even());

	cout << "\nВектор после stable_partition:\n";
	show(v);*/

#endif // 0




	//partial_sum ------------------------------------------------------------------
	/*
	создается новая последовательность, в которой значение каждого элемента равно
	сумме всех предидущих, включая данный
	*/
#if 0

	vector<int> v{ 1, 2, 6, 8, 7, 10, 2 }, v2(7);
	show(v);

	partial_sum(v.begin(), v.end(), v2.begin());
	show(v2);

#endif


	//iota---------------------------------------------------------------------------
	/*

	iota -  Присваивает каждому элементу диапазона [first,last)последовательные
	значения val ,  как если бы они были увеличены  ++val последующим написанием каждого элемента.
	*/
#if 0

	vector<int> t(10);
	iota(t.begin(), t.end(), -5);

	show(t);

#endif // 0



	//remove------------------------------------------------------------------
#if 0

	vector<int> v{ 25, -6, 9, 10, 25, -8, 19, 25, -30 };
	show(v);
	int value = 25;

	auto it = remove(v.begin(), v.end(), value);

	cout << endl << *it << "   индекс: " << distance(v.begin(), it) << endl;

	cout << "\nВектор после remove:\n";
	show(v);

	/*v.erase(it, v.end());

	cout << "\nВектор после erase:\n";
	show(v);*/


#endif // 0




	//remove_if----------------------------------------------------------------------

	// Самостоятельно: Удалить элементы по условию, отрицательные значения
#if 0

	vector<int> v{ 25, 3, -4, 22, -45, 5, 6, 8, 22, 9, -10, 25, -3, 45 };
	show(v);

	auto it = remove_if(v.begin(), v.end(), is_negative);// Надо дописать предикатную функцию
	//auto it = remove_if(v.begin(), v.end(), Negative());// Надо дописать предикат

	show(v);

	v.erase(it, v.end());

	show(v);


#endif // 0





	// copy---------------------------------------------------------------------
#if 0

	vector<int> v{ 25, 6, -3, 9, 78, 12 }, v1(6), v2;
	show(v);
	show(v1);
	show(v2);

	copy(v.begin(), v.end(), v1.begin());

	//copy(v.begin(), v.end(), v2.begin());// вылет
	copy(v1.begin(), v1.end(), back_inserter(v2));

	show(v1);

	show(v2);

#endif




	// Вывод вектора при помощи ostream_iterator и алгоритма copy
#if 0

	vector<int> v{ 25, 6, -3, 9, 78, 12 };

	ostream_iterator<int> out(cout, " | "); //Объявление объекта типа ostream_iterator<int> 
	copy(v.begin(), v.end(), out);

	cout << endl;
	copy(v.begin(), v.end(), ostream_iterator<int>(cout, " # "));

	cout << endl << endl;


#endif // 0

	// copy_if-------------------------------------------------------------------
#if 0

	vector<int> v{ 25, 6, -3, 9, 78, 12 };
	show(v);

	vector<int> vcet(v.size());// вектор для хранения четных элементов

	auto it = copy_if(v.begin(), v.end(), vcet.begin(), Even());// копируем четные элементы
	show(vcet);
	cout << "Индекс: " << distance(vcet.begin(), it) << endl;

	vcet.resize(distance(vcet.begin(), it));//корректируем размер
	cout << "\nВектор четных значений: ";
	show(vcet);


#endif // 0






	// <numeric>------------------------------------------------------------------
	//accumulate ------------------------------------------------------------------
	/*
	accumulate - вычисляет сумму значений элементов последовательности из диапазона,
	ограниченного парой итераторов [first,last], с начальным значением,
	которое задано параметром init(третий параметр).
	*/
#if 0

	vector<int>v{ 3, 6, 9, 45, 8, -9, 7, 2 };

	int res = accumulate(v.begin(), v.end(), 0);
	cout << "\nСумма значений вектора: " << res << endl;

#endif


	// Задача(самостоятельно): ------------------------------------------------------***
	// Изменить код метода рассчета среднего балла SudentSTL, используя алгоритм accumulate





	_getch();
	return 0;
};



/*
Предикат может быть функцией или функтором(объект-функция).
Предикаты - подмножество функторов, в которых тип возвращаемого значения operator() bool.

Функтор(объект-функция) - конструкция, которая предоставляет возможность
использовать объект как функцию.
Это может быть структура или класс, перегружающие оператор().
*/

/*
ФУНКТОРЫ и ПРЕДИКАТЫ - это классы, объекты которых похожи
					   на функцию (в них перегружен оператор () ).

- Требование для предиката - оператор () должен возвращать значение типа bool.

- Требование для функтора - у оператора ()
  тип возвращаемого значения должен быть отличным от bool.

*/



